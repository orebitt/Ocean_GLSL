var e;e=function(e,t){for(var n=["webgl","experimental-webgl","webkit-3d","moz-webgl"],r=null,i=0;i<n.length;++i){try{r=e.getContext(n[i],t)}catch(e){}if(r)break}return r};!function(){var e={enable:{0:!0},disable:{0:!0},getParameter:{0:!0},drawArrays:{0:!0},drawElements:{0:!0,2:!0},createShader:{0:!0},getShaderParameter:{1:!0},getProgramParameter:{1:!0},getVertexAttrib:{1:!0},vertexAttribPointer:{2:!0},bindTexture:{0:!0},activeTexture:{0:!0},getTexParameter:{0:!0,1:!0},texParameterf:{0:!0,1:!0},texParameteri:{0:!0,1:!0,2:!0},texImage2D:{0:!0,2:!0,6:!0,7:!0},texSubImage2D:{0:!0,6:!0,7:!0},copyTexImage2D:{0:!0,2:!0},copyTexSubImage2D:{0:!0},generateMipmap:{0:!0},bindBuffer:{0:!0},bufferData:{0:!0,2:!0},bufferSubData:{0:!0},getBufferParameter:{0:!0,1:!0},pixelStorei:{0:!0,1:!0},readPixels:{4:!0,5:!0},bindRenderbuffer:{0:!0},bindFramebuffer:{0:!0},checkFramebufferStatus:{0:!0},framebufferRenderbuffer:{0:!0,1:!0,2:!0},framebufferTexture2D:{0:!0,1:!0,2:!0},getFramebufferAttachmentParameter:{0:!0,1:!0,2:!0},getRenderbufferParameter:{0:!0,1:!0},renderbufferStorage:{0:!0,1:!0},clear:{0:!0},depthFunc:{0:!0},blendFunc:{0:!0,1:!0},blendFuncSeparate:{0:!0,1:!0,2:!0,3:!0},blendEquation:{0:!0},blendEquationSeparate:{0:!0,1:!0},stencilFunc:{0:!0},stencilFuncSeparate:{0:!0,1:!0},stencilMaskSeparate:{0:!0},stencilOp:{0:!0,1:!0,2:!0},stencilOpSeparate:{0:!0,1:!0,2:!0,3:!0},cullFace:{0:!0},frontFace:{0:!0}},t=null;function n(e){if(null==t)for(var n in t={},e)"number"==typeof e[n]&&(t[e[n]]=n)}function r(){if(null==t)throw"WebGLDebugUtils.init(ctx) not called"}function i(e){r();var n=t[e];return void 0!==n?n:"*UNKNOWN WebGL ENUM (0x"+e.toString(16)+")"}function o(t,n,r){var o=e[t];return void 0!==o&&o[n]?i(r):r.toString()}function a(e){var t=e.getParameter(e.MAX_VERTEX_ATTRIBS),n=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,n);for(var r=0;r<t;++r)e.disableVertexAttribArray(r),e.vertexAttribPointer(r,4,e.FLOAT,!1,0,0),e.vertexAttrib1f(r,0);e.deleteBuffer(n);var i=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);for(r=0;r<i;++r)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_CUBE_MAP,null),e.bindTexture(e.TEXTURE_2D,null);for(e.activeTexture(e.TEXTURE0),e.useProgram(null),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindRenderbuffer(e.RENDERBUFFER,null),e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.DITHER),e.disable(e.SCISSOR_TEST),e.blendColor(0,0,0,0),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.clearColor(0,0,0,0),e.clearDepth(1),e.clearStencil(-1),e.colorMask(!0,!0,!0,!0),e.cullFace(e.BACK),e.depthFunc(e.LESS),e.depthMask(!0),e.depthRange(0,1),e.frontFace(e.CCW),e.hint(e.GENERATE_MIPMAP_HINT,e.DONT_CARE),e.lineWidth(1),e.pixelStorei(e.PACK_ALIGNMENT,4),e.pixelStorei(e.UNPACK_ALIGNMENT,4),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.UNPACK_COLORSPACE_CONVERSION_WEBGL&&e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.BROWSER_DEFAULT_WEBGL),e.polygonOffset(0,0),e.sampleCoverage(1,!1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilMask(4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.viewport(0,0,e.canvas.clientWidth,e.canvas.clientHeight),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT);e.getError(););}}();function t(e,t,r){var i=n(e,e.VERTEX_SHADER,t),o=n(e,e.FRAGMENT_SHADER,r);if(!i||!o)return null;var a=e.createProgram();if(!a)return null;if(e.attachShader(a,i),e.attachShader(a,o),e.linkProgram(a),!e.getProgramParameter(a,e.LINK_STATUS)){var s=e.getProgramInfoLog(a);return console.log("Failed to link program: "+s),e.deleteProgram(a),e.deleteShader(o),e.deleteShader(i),null}return a}function n(e,t,n){var r=e.createShader(t);if(null==r)return console.log("unable to create shader"),null;if(e.shaderSource(r,n),e.compileShader(r),!e.getShaderParameter(r,e.COMPILE_STATUS)){var i=e.getShaderInfoLog(r);return console.log("Failed to compile shader: "+i),e.deleteShader(r),null}return r}class r{constructor(e){var t=new Float32Array(3);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2]),this.elements=t}set(e){var t,n,r;if((n=e.elements)!==(r=this.elements)){for(t=0;t<3;++t)r[t]=n[t];return this}}add(e){for(var t=0;t<3;t++)this.elements[t]+=e.elements[t];return this}sub(e){for(var t=0;t<3;t++)this.elements[t]-=e.elements[t];return this}div(e){for(var t=0;t<3;t++)this.elements[t]/=e;return this}mul(e){for(var t=0;t<3;t++)this.elements[t]*=e;return this}static dot(e,t){let n=0;for(var r=0;r<3;r++)n+=e.elements[r]*t.elements[r];return n}static cross(e,t){let n=e.elements,i=t.elements,o=n[1]*i[2]-n[2]*i[1],a=-1*(n[0]*i[2]-n[2]*i[0]),s=n[0]*i[1]-n[1]*i[0];return new r([o,a,s])}magnitude(){let e=0;for(var t=0;t<3;t++)e+=this.elements[t]*this.elements[t];return e=Math.sqrt(e),e}normalize(){return this.div(this.magnitude()),this}}class i{constructor(e){var t=new Float32Array(4);e&&"object"==typeof e&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3]),this.elements=t}}class o{constructor(e){var t,n,r;if(e&&"object"==typeof e&&e.hasOwnProperty("elements")){for(n=e.elements,r=new Float32Array(16),t=0;t<16;++t)r[t]=n[t];this.elements=r}else this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}setIdentity(){var e=this.elements;return e[0]=1,e[4]=0,e[8]=0,e[12]=0,e[1]=0,e[5]=1,e[9]=0,e[13]=0,e[2]=0,e[6]=0,e[10]=1,e[14]=0,e[3]=0,e[7]=0,e[11]=0,e[15]=1,this}set(e){var t,n,r;if((n=e.elements)!==(r=this.elements)){for(t=0;t<16;++t)r[t]=n[t];return this}}multiply(e){var t,n,r,i,o,a,s,l;if(n=this.elements,r=this.elements,n===(i=e.elements))for(i=new Float32Array(16),t=0;t<16;++t)i[t]=n[t];for(t=0;t<4;t++)o=r[t],a=r[t+4],s=r[t+8],l=r[t+12],n[t]=o*i[0]+a*i[1]+s*i[2]+l*i[3],n[t+4]=o*i[4]+a*i[5]+s*i[6]+l*i[7],n[t+8]=o*i[8]+a*i[9]+s*i[10]+l*i[11],n[t+12]=o*i[12]+a*i[13]+s*i[14]+l*i[15];return this}concat(e){return this.multiply(e)}multiplyVector3(e){var t=this.elements,n=e.elements,i=new r,o=i.elements;return o[0]=n[0]*t[0]+n[1]*t[4]+n[2]*t[8]+t[12],o[1]=n[0]*t[1]+n[1]*t[5]+n[2]*t[9]+t[13],o[2]=n[0]*t[2]+n[1]*t[6]+n[2]*t[10]+t[14],i}multiplyVector4(e){var t=this.elements,n=e.elements,r=new i,o=r.elements;return o[0]=n[0]*t[0]+n[1]*t[4]+n[2]*t[8]+n[3]*t[12],o[1]=n[0]*t[1]+n[1]*t[5]+n[2]*t[9]+n[3]*t[13],o[2]=n[0]*t[2]+n[1]*t[6]+n[2]*t[10]+n[3]*t[14],o[3]=n[0]*t[3]+n[1]*t[7]+n[2]*t[11]+n[3]*t[15],r}transpose(){var e,t;return t=(e=this.elements)[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setInverseOf(e){var t,n,r,i,o;if(n=e.elements,r=this.elements,(i=new Float32Array(16))[0]=n[5]*n[10]*n[15]-n[5]*n[11]*n[14]-n[9]*n[6]*n[15]+n[9]*n[7]*n[14]+n[13]*n[6]*n[11]-n[13]*n[7]*n[10],i[4]=-n[4]*n[10]*n[15]+n[4]*n[11]*n[14]+n[8]*n[6]*n[15]-n[8]*n[7]*n[14]-n[12]*n[6]*n[11]+n[12]*n[7]*n[10],i[8]=n[4]*n[9]*n[15]-n[4]*n[11]*n[13]-n[8]*n[5]*n[15]+n[8]*n[7]*n[13]+n[12]*n[5]*n[11]-n[12]*n[7]*n[9],i[12]=-n[4]*n[9]*n[14]+n[4]*n[10]*n[13]+n[8]*n[5]*n[14]-n[8]*n[6]*n[13]-n[12]*n[5]*n[10]+n[12]*n[6]*n[9],i[1]=-n[1]*n[10]*n[15]+n[1]*n[11]*n[14]+n[9]*n[2]*n[15]-n[9]*n[3]*n[14]-n[13]*n[2]*n[11]+n[13]*n[3]*n[10],i[5]=n[0]*n[10]*n[15]-n[0]*n[11]*n[14]-n[8]*n[2]*n[15]+n[8]*n[3]*n[14]+n[12]*n[2]*n[11]-n[12]*n[3]*n[10],i[9]=-n[0]*n[9]*n[15]+n[0]*n[11]*n[13]+n[8]*n[1]*n[15]-n[8]*n[3]*n[13]-n[12]*n[1]*n[11]+n[12]*n[3]*n[9],i[13]=n[0]*n[9]*n[14]-n[0]*n[10]*n[13]-n[8]*n[1]*n[14]+n[8]*n[2]*n[13]+n[12]*n[1]*n[10]-n[12]*n[2]*n[9],i[2]=n[1]*n[6]*n[15]-n[1]*n[7]*n[14]-n[5]*n[2]*n[15]+n[5]*n[3]*n[14]+n[13]*n[2]*n[7]-n[13]*n[3]*n[6],i[6]=-n[0]*n[6]*n[15]+n[0]*n[7]*n[14]+n[4]*n[2]*n[15]-n[4]*n[3]*n[14]-n[12]*n[2]*n[7]+n[12]*n[3]*n[6],i[10]=n[0]*n[5]*n[15]-n[0]*n[7]*n[13]-n[4]*n[1]*n[15]+n[4]*n[3]*n[13]+n[12]*n[1]*n[7]-n[12]*n[3]*n[5],i[14]=-n[0]*n[5]*n[14]+n[0]*n[6]*n[13]+n[4]*n[1]*n[14]-n[4]*n[2]*n[13]-n[12]*n[1]*n[6]+n[12]*n[2]*n[5],i[3]=-n[1]*n[6]*n[11]+n[1]*n[7]*n[10]+n[5]*n[2]*n[11]-n[5]*n[3]*n[10]-n[9]*n[2]*n[7]+n[9]*n[3]*n[6],i[7]=n[0]*n[6]*n[11]-n[0]*n[7]*n[10]-n[4]*n[2]*n[11]+n[4]*n[3]*n[10]+n[8]*n[2]*n[7]-n[8]*n[3]*n[6],i[11]=-n[0]*n[5]*n[11]+n[0]*n[7]*n[9]+n[4]*n[1]*n[11]-n[4]*n[3]*n[9]-n[8]*n[1]*n[7]+n[8]*n[3]*n[5],i[15]=n[0]*n[5]*n[10]-n[0]*n[6]*n[9]-n[4]*n[1]*n[10]+n[4]*n[2]*n[9]+n[8]*n[1]*n[6]-n[8]*n[2]*n[5],0===(o=n[0]*i[0]+n[1]*i[4]+n[2]*i[8]+n[3]*i[12]))return this;for(o=1/o,t=0;t<16;t++)r[t]=i[t]*o;return this}invert(){return this.setInverseOf(this)}setOrtho(e,t,n,r,i,o){var a,s,l,c;if(e===t||n===r||i===o)throw"null frustum";return s=1/(t-e),l=1/(r-n),c=1/(o-i),(a=this.elements)[0]=2*s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*l,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=-2*c,a[11]=0,a[12]=-(t+e)*s,a[13]=-(r+n)*l,a[14]=-(o+i)*c,a[15]=1,this}ortho(e,t,n,r,i,a){return this.concat((new o).setOrtho(e,t,n,r,i,a))}setFrustum(e,t,n,r,i,o){var a,s,l,c;if(e===t||r===n||i===o)throw"null frustum";if(i<=0)throw"near <= 0";if(o<=0)throw"far <= 0";return s=1/(t-e),l=1/(r-n),c=1/(o-i),(a=this.elements)[0]=2*i*s,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2*i*l,a[6]=0,a[7]=0,a[8]=(t+e)*s,a[9]=(r+n)*l,a[10]=-(o+i)*c,a[11]=-1,a[12]=0,a[13]=0,a[14]=-2*i*o*c,a[15]=0,this}frustum(e,t,n,r,i,a){return this.concat((new o).setFrustum(e,t,n,r,i,a))}setPerspective(e,t,n,r){var i,o,a,s;if(n===r||0===t)throw"null frustum";if(n<=0)throw"near <= 0";if(r<=0)throw"far <= 0";if(e=Math.PI*e/180/2,0===(a=Math.sin(e)))throw"null frustum";return o=1/(r-n),s=Math.cos(e)/a,(i=this.elements)[0]=s/t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=s,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=-(r+n)*o,i[11]=-1,i[12]=0,i[13]=0,i[14]=-2*n*r*o,i[15]=0,this}perspective(e,t,n,r){return this.concat((new o).setPerspective(e,t,n,r))}setScale(e,t,n){var r=this.elements;return r[0]=e,r[4]=0,r[8]=0,r[12]=0,r[1]=0,r[5]=t,r[9]=0,r[13]=0,r[2]=0,r[6]=0,r[10]=n,r[14]=0,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}scale(e,t,n){var r=this.elements;return r[0]*=e,r[4]*=t,r[8]*=n,r[1]*=e,r[5]*=t,r[9]*=n,r[2]*=e,r[6]*=t,r[10]*=n,r[3]*=e,r[7]*=t,r[11]*=n,this}setTranslate(e,t,n){var r=this.elements;return r[0]=1,r[4]=0,r[8]=0,r[12]=e,r[1]=0,r[5]=1,r[9]=0,r[13]=t,r[2]=0,r[6]=0,r[10]=1,r[14]=n,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}translate(e,t,n){var r=this.elements;return r[12]+=r[0]*e+r[4]*t+r[8]*n,r[13]+=r[1]*e+r[5]*t+r[9]*n,r[14]+=r[2]*e+r[6]*t+r[10]*n,r[15]+=r[3]*e+r[7]*t+r[11]*n,this}setRotate(e,t,n,r){var i,o,a,s,l,c,f,g,v,m,u,h;return e=Math.PI*e/180,i=this.elements,o=Math.sin(e),a=Math.cos(e),0!==t&&0===n&&0===r?(t<0&&(o=-o),i[0]=1,i[4]=0,i[8]=0,i[12]=0,i[1]=0,i[5]=a,i[9]=-o,i[13]=0,i[2]=0,i[6]=o,i[10]=a,i[14]=0,i[3]=0,i[7]=0,i[11]=0,i[15]=1):0===t&&0!==n&&0===r?(n<0&&(o=-o),i[0]=a,i[4]=0,i[8]=o,i[12]=0,i[1]=0,i[5]=1,i[9]=0,i[13]=0,i[2]=-o,i[6]=0,i[10]=a,i[14]=0,i[3]=0,i[7]=0,i[11]=0,i[15]=1):0===t&&0===n&&0!==r?(r<0&&(o=-o),i[0]=a,i[4]=-o,i[8]=0,i[12]=0,i[1]=o,i[5]=a,i[9]=0,i[13]=0,i[2]=0,i[6]=0,i[10]=1,i[14]=0,i[3]=0,i[7]=0,i[11]=0,i[15]=1):(1!==(s=Math.sqrt(t*t+n*n+r*r))&&(t*=l=1/s,n*=l,r*=l),c=1-a,f=t*n,g=n*r,v=r*t,m=t*o,u=n*o,h=r*o,i[0]=t*t*c+a,i[1]=f*c+h,i[2]=v*c-u,i[3]=0,i[4]=f*c-h,i[5]=n*n*c+a,i[6]=g*c+m,i[7]=0,i[8]=v*c+u,i[9]=g*c-m,i[10]=r*r*c+a,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1),this}rotate(e,t,n,r){return this.concat((new o).setRotate(e,t,n,r))}setLookAt(e,t,n,r,i,o,a,s,l){var c,f,g,v,m,u,h,x,d,w,y,p;return f=r-e,g=i-t,v=o-n,u=(g*=m=1/Math.sqrt(f*f+g*g+v*v))*l-(v*=m)*s,h=v*a-(f*=m)*l,x=f*s-g*a,w=(h*=d=1/Math.sqrt(u*u+h*h+x*x))*v-(x*=d)*g,y=x*f-(u*=d)*v,p=u*g-h*f,(c=this.elements)[0]=u,c[1]=w,c[2]=-f,c[3]=0,c[4]=h,c[5]=y,c[6]=-g,c[7]=0,c[8]=x,c[9]=p,c[10]=-v,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,this.translate(-e,-t,-n)}lookAt(e,t,n,r,i,a,s,l,c){return this.concat((new o).setLookAt(e,t,n,r,i,a,s,l,c))}dropShadow(e,t){var n=new o,r=n.elements,i=e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3];return r[0]=i-t[0]*e[0],r[1]=-t[1]*e[0],r[2]=-t[2]*e[0],r[3]=-t[3]*e[0],r[4]=-t[0]*e[1],r[5]=i-t[1]*e[1],r[6]=-t[2]*e[1],r[7]=-t[3]*e[1],r[8]=-t[0]*e[2],r[9]=-t[1]*e[2],r[10]=i-t[2]*e[2],r[11]=-t[3]*e[2],r[12]=-t[0]*e[3],r[13]=-t[1]*e[3],r[14]=-t[2]*e[3],r[15]=i-t[3]*e[3],this.concat(n)}dropShadowDirectionally(e,t,n,r,i,o,a,s,l){var c=r*e+i*t+o*n;return this.dropShadow([e,t,n,-c],[a,s,l,0])}}const a="\n  precision mediump float;\n  attribute vec3 position;\n  attribute vec2 uv;\n  attribute vec3 normal;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 normalMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n\n  varying vec3 vNormal;\n\n  void main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n    vNormal = (normalMatrix * vec4(normal, 1.0)).xyz;\n  }\n  ",s="\n  precision mediump float;\n  varying vec3 vNormal;\n\n  void main() {\n    vec3 norm = normalize(vNormal);\n    \n    gl_FragColor = vec4(norm, 1.0);\n  }\n  ";const l=new class{constructor(e=1,t=1){this.vertexBuffer=null,this.indexBuffer=null,this.uvBuffer=null,this.normalBuffer=null,this.vertexShader=a,this.fragmentShader=s,this.program=null,this.vertices=null,this.indices=null,this.uvs=null,this.normals=null,this.position=new r([0,0,0]),this.rotation=new r([0,0,0]),this.scale=new r([1,1,1]),this.modelMatrix=new o,this.normalMatrix=new o,this.generatePlane(e,t)}setShaders(e,t){this.vertexShader=e,this.fragmentShader=t,this.program=null}generatePlane(e,t){const n=1/e,r=1/e,i=[],o=[],a=[],s=[];for(let l=0;l<t+1;l++){const c=l*r-.5;for(let r=0;r<e+1;r++){let o=r*n-.5;i.push(o,-c,0),s.push(0,0,1),a.push(r/e),a.push(1-l/t)}for(let n=0;n<t;n++)for(let t=0;t<e;t++){let r=t+(e+1)*n,i=t+(e+1)*(n+1),a=t+1+(e+1)*(n+1),s=t+1+(e+1)*n;o.push(r,i,s),o.push(i,a,s)}this.vertices=new Float32Array(i),this.indices=new Uint16Array(o),this.uvs=new Float32Array(a),this.normals=new Float32Array(s)}}calculateMatrix(){let[e,t,n]=this.position.elements,[r,i,o]=this.rotation.elements,[a,s,l]=this.scale.elements;this.modelMatrix.setTranslate(e,t,n).rotate(r,1,0,0).rotate(i,0,1,0).rotate(o,0,0,1).scale(a,s,l),this.normalMatrix.set(this.modelMatrix).invert().transpose()}render(e,n){null===this.program&&(this.program=t(e,this.vertexShader,this.fragmentShader),this.program||console.error("could not compile shader")),e.useProgram(this.program),null===this.vertexBuffer&&(this.vertexBuffer=e.createBuffer()),null===this.indexBuffer&&(this.indexBuffer=e.createBuffer()),null===this.uvBuffer&&(this.uvBuffer=e.createBuffer()),null===this.normalBuffer&&(this.normalBuffer=e.createBuffer()),this.calculateMatrix(),n.calculateViewProjection();const r=e.getUniformLocation(this.program,"uTime"),i=e.getAttribLocation(this.program,"position"),o=e.getAttribLocation(this.program,"uv"),a=e.getAttribLocation(this.program,"normal"),s=e.getUniformLocation(this.program,"modelMatrix"),l=e.getUniformLocation(this.program,"normalMatrix"),c=e.getUniformLocation(this.program,"viewMatrix"),f=e.getUniformLocation(this.program,"projectionMatrix");e.uniform1f(r,performance.now()/1e3),e.uniformMatrix4fv(s,!1,this.modelMatrix.elements),e.uniformMatrix4fv(l,!1,this.normalMatrix.elements),e.uniformMatrix4fv(c,!1,n.viewMatrix.elements),e.uniformMatrix4fv(f,!1,n.projectionMatrix.elements),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,this.vertices,e.DYNAMIC_DRAW),e.vertexAttribPointer(i,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i),e.bindBuffer(e.ARRAY_BUFFER,this.uvBuffer),e.bufferData(e.ARRAY_BUFFER,this.uvs,e.DYNAMIC_DRAW),e.vertexAttribPointer(o,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(o),e.bindBuffer(e.ARRAY_BUFFER,this.normalBuffer),e.bufferData(e.ARRAY_BUFFER,this.normals,e.DYNAMIC_DRAW),e.vertexAttribPointer(a,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(a),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indices,e.DYNAMIC_DRAW),e.drawElements(e.TRIANGLES,this.indices.length,e.UNSIGNED_SHORT,0)}}(30,30);l.scale.mul(100),l.rotation.elements[0]=-90,l.setShaders('\n  precision mediump float;\n  attribute vec3 position;\n  attribute vec2 uv;\n  attribute vec3 normal;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 normalMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  uniform float uTime; // ADD THIS\n\n  varying vec3 vNormal;\n  varying float vWaveHeight;\n\n  float rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n  }\n\n  //\n  // GLSL textureless classic 3D noise "cnoise",\n  // with an RSL-style periodic variant "pnoise".\n  // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n  // Version: 2011-10-11\n  //\n  // Many thanks to Ian McEwan of Ashima Arts for the\n  // ideas for permutation and gradient selection.\n  //\n  // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n  // Distributed under the MIT license. See LICENSE file.\n  // https://github.com/ashima/webgl-noise\n  //\n\n  vec3 mod289(vec3 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 mod289(vec4 x)\n  {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n\n  vec4 permute(vec4 x)\n  {\n    return mod289(((x*34.0)+1.0)*x);\n  }\n\n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n\n  vec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n  }\n\n  // Classic Perlin noise\n  float cnoise(vec3 P)\n  {\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n  }\n\n  void main() {\n    vec4 transformedPosition = modelMatrix * vec4(position, 1.0);\n\n    float waveIntensity = cnoise(vec3(transformedPosition.xz, uTime * 0.2));\n\n    transformedPosition.y += waveIntensity;\n\n    gl_Position = projectionMatrix * viewMatrix * transformedPosition;\n    vNormal = (normalMatrix * vec4(normal, 1.0)).xyz;\n    vWaveHeight = (waveIntensity + 2.0) * 0.25; // map waves from [-2,2] to [0,1]\n  }\n  ',"\n  precision mediump float;\n  varying vec3 vNormal;\n  varying float vWaveHeight;\n\n  void main() {\n    vec3 norm = normalize(vNormal);\n\n    vec3 color = vec3(0.15, 0.35, 0.75); // bluish color\n\n    color = mix(color, vec3(1.0), smoothstep(0.35, 1.0, vWaveHeight));\n    \n    gl_FragColor = vec4(color, 1.0);\n  }\n  ");var c=l;const f=new class{constructor(e=.5,t=3,n=2){this.vertexBuffer=null,this.indexBuffer=null,this.uvBuffer=null,this.normalBuffer=null,this.vertexShader=a,this.fragmentShader=s,this.program=null,this.vertices=null,this.indices=null,this.uvs=null,this.normals=null,this.position=new r([0,0,0]),this.rotation=new r([0,0,0]),this.scale=new r([1,1,1]),this.modelMatrix=new o,this.normalMatrix=new o,t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n)),this.generateSphere(e,t,n)}setShaders(e,t){this.vertexShader=e,this.fragmentShader=t,this.program=null}generateSphere(e,t,n){let i=0;const o=[],a=new r,s=new r,l=[],c=[],f=[],g=[];for(let r=0;r<=n;r++){const l=[],v=r/n;let m=0;0===r?m=.5/t:r===n&&(m=-.5/t);for(let n=0;n<=t;n++){const r=n/t;a.elements[0]=-e*Math.cos(r*Math.PI*2)*Math.sin(v*Math.PI),a.elements[1]=e*Math.cos(v*Math.PI),a.elements[2]=e*Math.sin(r*Math.PI*2)*Math.sin(v*Math.PI),c.push(...a.elements),s.set(a).normalize(),f.push(...s.elements),g.push(r+m,1-v),l.push(i++)}o.push(l)}for(let e=0;e<n;e++)for(let r=0;r<t;r++){const t=o[e][r+1],i=o[e][r],a=o[e+1][r],s=o[e+1][r+1];0!==e&&l.push(t,i,s),e!==n-1&&l.push(i,a,s)}this.vertices=new Float32Array(c),this.indices=new Uint16Array(l),this.uvs=new Float32Array(g),this.normals=new Float32Array(f)}calculateMatrix(){let[e,t,n]=this.position.elements,[r,i,o]=this.rotation.elements,[a,s,l]=this.scale.elements;this.modelMatrix.setTranslate(e,t,n).rotate(r,1,0,0).rotate(i,0,1,0).rotate(o,0,0,1).scale(a,s,l),this.normalMatrix.set(this.modelMatrix).invert().transpose()}render(e,n){null===this.program&&(this.program=t(e,this.vertexShader,this.fragmentShader),this.program||console.error("could not compile shader")),e.useProgram(this.program);const r=e.getUniformLocation(this.program,"uTime");e.uniform1f(r,performance.now()/1e3),null===this.vertexBuffer&&(this.vertexBuffer=e.createBuffer()),null===this.indexBuffer&&(this.indexBuffer=e.createBuffer()),null===this.uvBuffer&&(this.uvBuffer=e.createBuffer()),null===this.normalBuffer&&(this.normalBuffer=e.createBuffer()),this.calculateMatrix(),n.calculateViewProjection();const i=e.getAttribLocation(this.program,"position"),o=e.getAttribLocation(this.program,"uv"),a=e.getAttribLocation(this.program,"normal"),s=e.getUniformLocation(this.program,"modelMatrix"),l=e.getUniformLocation(this.program,"normalMatrix"),c=e.getUniformLocation(this.program,"viewMatrix"),f=e.getUniformLocation(this.program,"projectionMatrix");e.uniformMatrix4fv(s,!1,this.modelMatrix.elements),e.uniformMatrix4fv(l,!1,this.normalMatrix.elements),e.uniformMatrix4fv(c,!1,n.viewMatrix.elements),e.uniformMatrix4fv(f,!1,n.projectionMatrix.elements),e.bindBuffer(e.ARRAY_BUFFER,this.vertexBuffer),e.bufferData(e.ARRAY_BUFFER,this.vertices,e.DYNAMIC_DRAW),e.vertexAttribPointer(i,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i),e.bindBuffer(e.ARRAY_BUFFER,this.uvBuffer),e.bufferData(e.ARRAY_BUFFER,this.uvs,e.DYNAMIC_DRAW),e.vertexAttribPointer(o,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(o),e.bindBuffer(e.ARRAY_BUFFER,this.normalBuffer),e.bufferData(e.ARRAY_BUFFER,this.normals,e.DYNAMIC_DRAW),e.vertexAttribPointer(a,3,e.FLOAT,!1,0,0),e.enableVertexAttribArray(a),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,this.indices,e.DYNAMIC_DRAW),e.drawElements(e.TRIANGLES,this.indices.length,e.UNSIGNED_SHORT,0)}}(50,20,20);f.setShaders("\n  precision mediump float;\n  attribute vec3 position;\n  attribute vec2 uv;\n  attribute vec3 normal;\n\n  uniform mat4 modelMatrix;\n  uniform mat4 normalMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  \n  varying vec3 vPos;\n\n  void main() {\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n\n    vPos = modelPosition.xyz;\n  }\n",'\n//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\nprecision mediump float;\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n\n/*\noriginal_author: Patricio Gonzalez Vivo\ndescription: Fractal Brownian Motion\nuse: fbm(<vec2> pos)\noptions:\n    FBM_OCTAVES: numbers of octaves. Default is 4.\n    FBM_NOISE_FNC(POS_UV): noise function to use Default \'snoise(POS_UV)\' (simplex noise)\n    FBM_VALUE_INITIAL: initial value. Default is 0.\n    FBM_SCALE_SCALAR: scalar. Defualt is 2.\n    FBM_AMPLITUD_INITIAL: initial amplitud value. Default is 0.5\n    FBM_AMPLITUD_SCALAR: amplitud scalar. Default is 0.5\n*/\n\n#ifndef FBM_OCTAVES\n#define FBM_OCTAVES 4\n#endif\n\n#ifndef FBM_NOISE_FNC\n#define FBM_NOISE_FNC(POS_UV) cnoise(POS_UV)\n#endif\n\n#ifndef FBM_NOISE2_FNC\n#define FBM_NOISE2_FNC(POS_UV) FBM_NOISE_FNC(POS_UV)\n#endif\n\n#ifndef FBM_NOISE3_FNC\n#define FBM_NOISE3_FNC(POS_UV) FBM_NOISE_FNC(POS_UV)\n#endif\n\n\n#ifndef FBM_NOISE_TYPE\n#define FBM_NOISE_TYPE float\n#endif\n\n#ifndef FBM_VALUE_INITIAL\n#define FBM_VALUE_INITIAL 0.0\n#endif\n\n#ifndef FBM_SCALE_SCALAR\n#define FBM_SCALE_SCALAR 2.0\n#endif\n\n#ifndef FBM_AMPLITUD_INITIAL\n#define FBM_AMPLITUD_INITIAL 0.5\n#endif\n\n#ifndef FBM_AMPLITUD_SCALAR\n#define FBM_AMPLITUD_SCALAR 0.5\n#endif\n\n#ifndef FNC_FBM\n#define FNC_FBM\n\nFBM_NOISE_TYPE fbm(in vec4 pos) {\n    // Initial values\n    FBM_NOISE_TYPE value = FBM_NOISE_TYPE(FBM_VALUE_INITIAL);\n    float amplitud = FBM_AMPLITUD_INITIAL;\n\n    // Loop of octaves\n    for (int i = 0; i < FBM_OCTAVES; i++) {\n        value += amplitud * FBM_NOISE3_FNC(pos);\n        pos *= FBM_SCALE_SCALAR;\n        amplitud *= FBM_AMPLITUD_SCALAR;\n    }\n    return value;\n}\n#endif\n\n\n\n  #define SUN_POS vec3(0.0, 8.68240888, -49.24038765)\n  #define SUN_SIZE 10.0 // ADD THIS\n  varying vec3 vPos;\n  uniform float uTime;\n  void main() {\n    float d = distance(SUN_POS, vPos); // dont need the divide anymore\n    float sunIntensity = SUN_SIZE / d;\n    vec3 color = vec3(0.1, 0.12, 0.4); // pick ur sky color if u want\n    vec3 sunColor = vec3(0.95, 0.85, 0.5); // pick sun color\n    color = mix(color, sunColor, pow(sunIntensity, 2.0));\n    float mist = fbm(vec4(vPos * 0.02, uTime * 0.05));    vec3 mistColor = vec3(0.7);\n    color += mistColor * mist;\n    gl_FragColor = vec4(color, 1.0);\n  }\n');var g=f;var v,m,u=function(){var e=document.getElementById("webgl");e.width=window.innerWidth,e.height=window.innerHeight;const t=e.getContext("webgl");return t||console.log("Failed to get the rendering context for WebGL"),t.viewport(0,0,e.width,e.height),t.enable(t.DEPTH_TEST),t.clearColor(.2,.2,.25,1),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT),window.addEventListener("resize",(e=>{t.canvas.width=window.innerWidth,t.canvas.height=window.innerHeight,t.viewport(0,0,t.canvas.width,t.canvas.height)})),t}();((m=t(v=u,"\n  precision mediump float;\n  attribute vec3 position;\n  attribute vec2 uv;\n  attribute vec3 normal;\n  \n  uniform mat4 modelMatrix;\n  uniform mat4 normalMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  \n  varying vec3 vNormal;\n  \n  void main() {\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.0);\n    vNormal = (normalMatrix * vec4(normal, 1.0)).xyz;\n  }\n  ","\n  precision mediump float;\n  varying vec3 vNormal;\n\n  void main() {\n    vec3 norm = normalize(vNormal);\n    \n    gl_FragColor = vec4(norm, 1.0);\n  }\n"))?(v.useProgram(m),v.program=m,1):(console.log("Failed to create program"),0))||console.error("Could not init shaders");const h=new class{constructor(e=[0,1,2],t=[0,0,0]){this.position=new r(e),this.rotation=new r(t),this.viewMatrix=new o,this.projectionMatrix=new o,this.up=new r([0,1,0]),this.aspect=window.innerWidth/window.innerHeight,this.near=.01,this.far=100,this.fov=50,window.addEventListener("resize",(e=>{this.aspect=window.innerWidth/window.innerHeight,this.calculateViewProjection()})),this.calculateViewProjection()}calculateViewProjection(){let[e,t,n]=this.rotation.elements;this.viewMatrix.setTranslate(...this.position.elements),this.viewMatrix.rotate(t,0,1,0).rotate(e,1,0,0).rotate(n,0,0,1),this.viewMatrix.invert(),this.projectionMatrix.setPerspective(this.fov,this.aspect,this.near,this.far)}}([0,2.5,5],[0,1,0]),x=new class{constructor(e,t,n=[0,0,0]){this.canvas=e.canvas,this.camera=t,this.mouse=new r,this.rotation=new r(n),this.matrix=new o,this.dragging=!1,this.setHandlers()}setHandlers(){this.canvas.onmousedown=e=>{this.dragging=!0;let t=e.clientX/e.target.clientWidth*2-1,n=-e.clientY/e.target.clientHeight*2+1;this.mouse.elements.set([t,n,0])},this.canvas.onmouseup=this.canvas.onmouseleave=e=>{this.dragging=!1},this.canvas.onmousemove=e=>{let t=e.clientX/e.target.clientWidth*2-1,n=-e.clientY/e.target.clientHeight*2+1;if(this.dragging){let e=t-this.mouse.elements[0],r=n-this.mouse.elements[1];this.rotation.elements[0]-=50*r,this.rotation.elements[1]+=50*e,this.mouse.elements.set([t,n,0])}}}update(){let e=.8*this.camera.rotation.elements[0]+.2*this.rotation.elements[0],t=.8*this.camera.rotation.elements[1]+.2*this.rotation.elements[1];this.camera.rotation.elements.set([e,t,0])}}(u,h);!function e(){u.clear(u.COLOR_BUFFER_BIT|u.DEPTH_BUFFER_BIT),c.render(u,h),g.render(u,h),x.update(),requestAnimationFrame(e)}();
//# sourceMappingURL=index.14ce8b8d.js.map
